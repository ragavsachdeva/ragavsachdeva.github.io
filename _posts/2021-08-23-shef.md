---
layout: post
title:  shef - bake state machines in ROS
date: 2021-08-23
comments: True
description: A python wrapper around SMACH to simplify creating complex robot state machines in ROS. 
---

[shef](https://github.com/ragavsachdeva/shef){:target="\_blank"} is a wrapper around [smach](http://wiki.ros.org/smach){:target="\_blank"}, built with the intention of simplifying the process of creating and running complex hierarchical state machines in [ROS](https://www.ros.org/){:target="\_blank"}.

Let's look at an example:

Suppose you want to create a super simple state machine that sequentially executes three states: `StateA`, `StateB` and `StateC`.

More information on [states](#state) is provided later, but for now know that creating a state is as simple as implementing a `behaviour` function as follows:

{% highlight python linenos %}
    from state_machine.base._base_state import BaseState

    class StateA(BaseState):
        def __init__(self, name, tree, outcome, conditions):
            super().__init__(name, tree, outcome, conditions)
        
        def behaviour(self):
            print("Executing StateA")

    class StateB(BaseState):
        def __init__(self, name, tree, outcome, conditions):
            super().__init__(name, tree, outcome, conditions)
        
        def behaviour(self):
            print("Executing StateB")

    class StateC(BaseState):
        def __init__(self, name, tree, outcome, conditions):
            super().__init__(name, tree, outcome, conditions)
        
        def behaviour(self):
            print("Executing StateC")
{% endhighlight %}

Now, having implemented each of these states, the next step is to define how the program must transition between these states. For that, you'll need to implement something called a [transition state](#transition-state). In our case, a transition state that executes `StateA`, `StateB` and `StateC` sequentially might look something like this:

{% highlight python linenos %}
    from state_machine.states.base._base_transition_state import BaseTransitionState

    class SequentialTransitionState(BaseTransitionState):
        def __init__(self, name, tree, outcomes, conditions, ledger):
            super().__init__(name, tree, outcomes, conditions, ledger)
            self.index = -1

        def next_state(self):
            self.index += 1
            return self.child_states[self.index]
{% endhighlight %}

Finally, all we need to do is hook all of these individual states up into a state machine which can then be executed. That is done by defining a recipe file as:

{% highlight yaml linenos %}
    root:
      type: SimpleStateMachine
      transition_state: SequentialTransitionState
      child_states:
        state_a:
          type: StateA
        state_b:
          type: StateB
        state_c:
          type: StateC
{% endhighlight %}

and ... that's it! Everything else is taken care of for you by [shef](https://github.com/ragavsachdeva/shef){:target="\_blank"}. SHEF will parse this recipe file, construct a smach state machine under-the-hood and execute the states as per the transitions you define. It's that simple!

This was, of course, a very rudimentary example by design. SHEF allows you to do a whole bunch of complex stuff including:

* running states in parallel
* nesting state machines
* synchronisation e.g. "do not execute stateX while stateY is running" or "wait for stateB to finish before executing stateA" etc.
* preempt execution
* externally force state transition

and more. Keep reading for details!

**Table of Contents**
- [State](#state)
- [State Machine](#state-machine)
  - [ConcurrentStateMachine](#concurrentstatemachine)
  - [SimpleStateMachine](#simplestatemachine)
- [Transition State](#transition-state)
- [Recipes](#recipes)

#### State

In order to define your own state you will need to inherit the `BaseState` class and implement the `behaviour` function.

Here is an example of a custom state class:

{% highlight python linenos %}
import rospy
from state_machine.base._base_state import BaseState

class BusyWait(BaseState):
    """
    A simple state that infinitely busy-waits unless preempted.
    """

    def __init__(self, name, tree, outcome):
        super().__init__(name, tree, outcome)

    def behaviour(self):
        rospy.loginfo(
            "Running the BusyWait. \
            Expected behaviour is to infinitely wait unless pre-emptively killed."
        )
        while True:
            if self.preempt_requested():
                return
            rospy.sleep(1.0)

{% endhighlight %}

and that is it really. A state is the simplest element of the state machine which "does something" when its `behaviour` function is executed.

**YSK**

- Each state has a `self.data_store` dictionary object which is shared across all states (including the transition state) within a SimpleStateMachine. If you want to share data or pass messages to the sibling states, you can simply add it to the `data_store`.

- The state's data is persistent. In other words, any variables that you declare in the constructor of the state class will "remember" their value if the state machine enters the same state again. If you want to reset these parameters every time this state is executed, you should either initialise them in the `behaviour` function or reset them in the `self.tear_down` function which is inherited from `BaseState` (recommended).

- Inside the `behaviour` function, should you have some logic to exit the function if `self.preempt_requested()` flag returns true. See the code above for example. This is required to preempt the state. If your state takes a long time to execute, you should be frequently monitoring this flag (and not just once).

#### State Machine

A state machine is a container for a set of child states. There are two kinds of state machines that are implemented in [shef](https://github.com/ragavsachdeva/shef){:target="\_blank"} by default:

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0" style="text-align: center; padding: 50px;">
        <img class="img-fluid rounded" src="{{ site.baseurl }}/assets/img/blog_posts/2021-08-23-shef/state-machines.png">
    </div>
</div>

##### ConcurrentStateMachine

The concept of a concurrent state machine is quite straightforward. It runs all of its child states in concurrence ("in parallel") and exits once all of them have finished executing.

##### SimpleStateMachine

Despite the name, a simple state machine is a bit more complex than a concurrence state machine. The idea for this state machine is to execute its child states one at a time based on some pre-defined logic (transitions). Rather than allowing any child state to transition to any other child states, there is a concept of a [Tranisition State](Transition State) which all [other states](#state) are connected to. It is the responsibility of this transition state to manage the control flow of the program.

**YSK**

- As evident from the diagram above, it is possible to nest state machines.
- In a SimpleStateMachine, there will only be one active state at a time.
- Both SimpleStateMachine and ConcurrentStateMachine come with a "monitor". This monitor sets up a rostopic and constantly listens to it for any messages. Any communication across state machines will happen via this monitor (note this is different to communication within the state machine, for that we can use the `data_store` object). Currently it is only used for preemption.

#### Transition State

In order to define your own state you will need to inherit the `BaseTransitionState` class and implement the `next_state` function.

Here is an example of a custom transition state class:

{% highlight python linenos %}
from state_machine.base._base_transition_state import BaseTransitionState

class SequentialTransitionState(BaseTransitionState):
    """
    Transition state to sequentially execute all the child states.
    """

    def __init__(self, name, tree, outcomes, ledger):
        super().__init__(name, tree, outcomes, ledger)

    def next_state(self):
        index = 0
        if self.last_state is not None:
            index = self.child_states.index(self.last_state) + 1
        return self.child_states[index]

{% endhighlight %}

The logic to decide which state to go to next should reside inside the `next_state` function. In the example above, the transition state sequentially executes the [states](#state) in the order they were defined in the [recipe](#recipes) file.

**YSK**

- Each transition state has `self.child_states` which is a list of strings representing the name of the [states](#state) inside the SimpleStateMachine. To "go to" a particular state next, simply return the name of that state (string) from the `next_state` function. Note that the last element of `child_states` is special in that return this will exit the SimpleStateMachine.

- The transition state also keeps track of the last state that was executed inside the `self.last_state` variable. If the logic of where to go next relies on what you executed last, this variable would be useful. Note that its value is `None` by default if the program has yet to enter any of the child states.

- Unlike a [State](#state), the `self.tear_down` function gets executed when the entire SimpleStateMachine is exited (and not every time the transition state exits, which wouldn't add a lot of value). Any tear down functionality should go inside this function e.g. resetting any member variables.

- You also have access to the `self.get_device_name()` function that returns the name of the robot this transition state is a part of (e.g. small_scout_1). Note that this relies on the assumption that each robot has its own state machine and is named appropriately in the recipe file. Otherwise, this function return 'NO_DEVICE_FOUND`.

#### Recipes

A recipe file is really just a `.yml` file with information about constructing a state machine.

Here is an example:

{% highlight yaml linenos %}
    root:
      type: SimpleStateMachine
      transition_state: SequentialTransitionState
      child_states:
        child_1:
            type: ConcurrentStateMachine
            child_states:
                parallel_1:
                    type: DummyState
                parallel_2:
                    type: DummyState
        child_2:
          type: DummyState
{% endhighlight %}

**Explanation**:

This recipe file will create a state machine called `root` which is of type [SimpleStateMachine](#simplestatemachine) and has 2 child states: `child_1` and `child_2`. The `SequentialTransitionState` dictates the control flow between these child states. `child_1` in itself is a state machine of type [ConcurrentStateMachine](#concurrentstatemachine) while `child_2` is just a regular [state](#state) of type `DummyState`.

##### Defining your own recipes

Recipe files follow a tree structure and writing one is quite straightforward. There are only a handful of things to keep in mind:

**1\. `<state names>` vs `<keywords>` vs `<class names>`**

- There are a few words that have special meaning. We'll call them `<keywords>`. In the example above `type`, `transition_state` and `child_states` are all keywords. In addition, `import` is also a keyword.
- A `<state name>` is, well, the name of a state or state machine being defined. In the example above `root`, `child_1`, `child_2`, `parallel_1` and `parallel_2` are all state names. These can be whatever you want.
- `type` and `transition_state` keywords have values, which are `<class names>`. The parser will use this to instantiate a class with the matching name. Therefore, it is important to make sure that the `<class name>` is spelt correctly and there is in fact a class defined with the corresponding name. *Note: this class must be exposed in the `/state_machine/states/__init__.py` file.*

**2\. `type`**

There are only 2 types of *state machines*: `SimpleStateMachine` and `ConcurrentStateMachine`. For both of these, you will need to define the `child_states`. In addition, for a `SimpleStateMachine`, you will also need to specify the `transition_state`.

Everything else that is not a state machine, is a *simple state*. For these you only need to define the `type` as `<class name>`. These states cannot have `child_states`.

**3\. Each recipe file defines a single top-level state machine**

Going back to the idea of recipe files following a tree structure, each file must only define a single state or state machine at the top level. This is akin to the idea of a tree having a single root.

Here is an example of what you **cannot** do:

{% highlight yaml linenos %}
    my_custom_state_machine_1:
      type: SimpleStateMachine
      transition_state: SequentialTransitionState
      child_states:
        child_1:
          type: DummyState
    my_custom_state_machine_2:
      type: SimpleStateMachine
      transition_state: SequentialTransitionState
      child_states:
        child_1:
          type: DummyState
{% endhighlight %}

On the other hand, here are some examples of **valid** recipes:

{% highlight yaml linenos %}
    my_custom_state_machine:
      type: ConcurrentStateMachine
      child_states:
        child_1:
          type: DummyState
        child_2:
          type: DummyState
        child_3:
          type: DummyState   
{% endhighlight %}

{% highlight yaml linenos %}
    my_custom_state:
        type: DummyState
{% endhighlight %}

{% highlight yaml linenos %}
    my_top_state_machine:
      type: ConcurrentStateMachine
      child_states:
        my_custom_state_machine_1:
          type: SimpleStateMachine
          transition_state: SequentialTransitionState
          child_states:
            child_1:
              type: DummyState
        my_custom_state_machine_2:
          type: SimpleStateMachine
          transition_state: SequentialTransitionState
          child_states:
            child_1:
              type: DummyState
{% endhighlight %}

**4\. Each child state of a given state machine must have a unique `<state name>`**

The following recipe is **not** okay

{% highlight yaml linenos %}
    my_custom_state_machine:
    type: ConcurrentStateMachine
    child_states:
        child_1:
          type: DummyState
        child_1:
          type: DummyState
{% endhighlight %}

but this one is (even though two states share the same state name)

{% highlight yaml linenos %}
    my_custom_state_machine:
      type: ConcurrentStateMachine
      child_states:
        child_1:
          type: ConcurrentStateMachine
          child_states:
            same_name:
              type: DummyState
        child_2:
          type: ConcurrentStateMachine
          child_states:
            same_name:
              type: DummyState
{% endhighlight %}

**5\. Indentation matters**

After every `<state name>:` and `child_states:` you'll need to indent. This is standard yaml stuff.

**6\. Nesting recipe files**

Because of the indentation and nesting state machines, some of the recipe files can get really hairy. To allow for sanity and reusability, you can nest recipe files using the `import` keyword,

Consider the following recipe file:

{% highlight yaml linenos %}
    # filename: child_recipe.yml
    i_am_root:
      type: ConcurrentStateMachine
      child_states:
        child_1:
          type: DummyState
        child_2:
          type: DummyState

{% endhighlight %}

which is imported inside another recipe file as:

{% highlight yaml linenos %}
    # filename: parent_recipe.yml
    root:
      type: ConcurrentStateMachine
      child_states:
        i_am_not_root:
          import: child_recipe
{% endhighlight %}

The above is the equivalent of:

{% highlight yaml linenos %}
    # filename: same_as_parent_recipe.yml
    root:
      type: ConcurrentStateMachine
      child_states:
        i_am_not_root:
          type: ConcurrentStateMachine
          child_states:
            child_1:
              type: DummyState
            child_2:
              type: DummyState
{% endhighlight %}

Notice how the state name `i_am_root` disappears in the `same_as_parent_recipe.yml`. 

If you run `child_recipe.yml` as the main recipe, the top level state machine *will* have the name `i_am_root` but if you run `parent_recipe.yml`, the imported state machine has the name `i_am_not_root`.

Note: When importing a recipe file into another, you must define a `<state name>` for it in the parent recipe file. For instance, here is an example of something you **cannot** do.

{% highlight yaml linenos %}
    # filename: bad_parent_recipe.yml
    root:
      type: ConcurrentStateMachine
      child_states:
        import: child_recipe
{% endhighlight %}

This is mandated to ensure that you can import the same recipe file multiple times within the same state machine e.g.

{% highlight yaml linenos %}
    # filename: good_parent_recipe.yml
    root:
      type: ConcurrentStateMachine
      child_states:
        child_1:
          import: child_recipe
        child_2:
          import: child_recipe
{% endhighlight %}